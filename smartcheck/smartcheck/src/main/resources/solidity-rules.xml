<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Rules xmlns="http://www.smartdec.ru/SmartCheck/Conditions" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.smartdec.ru/SmartCheck/Conditions rules-grammar-schema.xsd ">
    <Rule>
        <RuleId>SOLIDITY_ADDRESS_HARDCODED</RuleId>
            <Patterns>
                <!-- Looks for hardcoded address 42 symbols long. -->
                <!-- Фиксирует адреса длиной в 42 символа. -->
                <Pattern patternId="adc165">
                    <Categories>
                         <Category>Solidity</Category>
                    </Categories>
                    <Severity>1</Severity>
                    <XPath>
                        //hexNumber[string-length() = 42]
                    </XPath>
                </Pattern>
                <!-- Looks for hardcoded address with less than 42 symbols that is not equal to 0x0. -->
                <!-- Фиксирует адреса длиной менее чем 42 символа и не равные 0x0. -->
                <Pattern patternId="b140cd">
                    <Categories>
                        <Category>Solidity</Category>
                    </Categories>
                    <Severity>1</Severity>
                    <XPath>
                        //hexNumber
                            [
                                (string-length() lt 42)
                                and (string-length() gt 30)
                                and not(matches(text()[1], "^0x0$"))
                            ]
                    </XPath>
                </Pattern>
                <!-- Looks for construction: address(<some constant>), where the constant is not equal to 0. -->
                <!-- Фиксирует конструкции: address(numberLiteral/decimalNumber), где numberLiteral/decimalNumber не равно 0. -->
                <Pattern patternId="f32db1">
                    <Categories>
                        <Category>Solidity</Category>
                    </Categories>
                    <Severity>1</Severity>
                    <XPath>
                        //typeConversion
                            [typeName[elementaryTypeName[matches(text()[1], "^address$")]]]
                            /expression
                                [primaryExpression/numberLiteral/decimalNumber]
                                [
                                    not(primaryExpression/numberLiteral/decimalNumber[matches(text()[1], "^0$")])
                                    and not(primaryExpression/identifier[matches(text()[1], "^this$")])
                                ]
                    </XPath>
                </Pattern>
            </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_ARRAY_LENGTH_MANIPULATION</RuleId>
        <Patterns>
            <!-- Looks for operations with dynamic array's length ".length": =, +=, -=, *=, /=, decrement. -->
            <!-- Фиксирует операции с длиной динамического массива ".length": =, +=, -=, *=, /=, декремент. -->
            <Pattern patternId="872bdd">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //expression
                        [expression[1][matches(text()[1], "\.length$")]]
                        [
                            matches(text()[1], "^=$")
                            or twoPlusMinusOperator/decrementOperator
                            or lvalueOperator
                                [
                                    mulLvalueOperator
                                    or minusLvalueOperator
                                    or plusLvalueOperator
                                    or divLvalueOperator
                                ]
                        ]
                </XPath>
            </Pattern>
            <!-- Looks for ".length++". -->
            <!-- Фиксирует конструкцию ".length++". -->
            <Pattern patternId="43ba1c">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //expression
                        [expression[1][matches(text()[1], "\.length$")]]
                        [twoPlusMinusOperator/incrementOperator]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_BALANCE_EQUALITY</RuleId>
        <Patterns>
            <!-- Looks for strict balance comparisons: ".balance ==", ".balance !=".  -->
            <!-- Фиксирует конструкции: ".balance ==", ".balance !=". -->
            <Pattern patternId="5094ad">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //expression
                        [comparison]
                        [
                            expression[matches(text()[1], "\.balance$")]
                            or expression/tupleExpression/expression[matches(text()[1], "\.balance$")]
                            or expression/expression[matches(text()[1], "\.balance$")]
                        ]

                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_BYTE_ARRAY_INSTEAD_BYTES</RuleId>
        <Patterns>
            <!-- Looks for construction: "byte[]". -->
            <!-- Фиксирует конструкцию: "byte[]". -->
            <Pattern patternId="f13a9f">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //typeName
                        [typeName/elementaryTypeName[text()[1] = "byte"]]
                        [matches(text()[1], "^\[.*\]$")]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_CONSTRUCTOR_RETURN</RuleId>
        <Patterns>
            <!-- Looks for assembly { return() } in constructor. -->
            <!-- Фиксирует assembly { return() } в конструкторе. -->
            <Pattern patternId="8saf21">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>3</Severity>
                <XPath>
                    //functionDefinition
                        [text()[1] = "constructor"]
                        //assemblyCall[matches(text()[1], "^return\(")]
                </XPath>
            </Pattern>
            <!-- Looks for assembly { return() } in old-style constructor. -->
            <!-- Фиксирует assembly { return() } в конструкторе старого типа. -->
            <Pattern patternId="7gaf21">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>3</Severity>
                <XPath>
                    //functionDefinition
                        [identifier[text()[1] = (ancestor::contractDefinition/identifier)]]
                        //assemblyCall[matches(text()[1], "^return\(")]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_CALL_WITHOUT_DATA</RuleId>
        <Patterns>
            <!-- Looks for low-level call() without data and gas limit. -->
            <!-- Фиксирует вызовы call с пустой датой и без ограничения газа. -->
            <Pattern patternId="om991k">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //functionCall
                        [functionName/identifier[text()[1] = "call"]]
                        [not(callArguments//expression)]
                        [not(gas/expression)]
                </XPath>
            </Pattern>
            <!-- Looks for low-level call() without data, but with gas limit. -->
            <!-- Фиксирует вызовы call с пустой датой, но с ограничением газа. -->
            <Pattern patternId="lr991l">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //functionCall
                        [functionName/identifier[text()[1] = "call"]]
                        [not(callArguments//expression)]
                        [gas/expression]
                </XPath>
            </Pattern>
            <!-- Looks for low-level call() with empty data ("") and without gas limit. -->
            <!-- Фиксирует вызовы call с пустой датой ("") и без ограничения газа. -->
            <Pattern patternId="111ppp">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //functionCall
                        [functionName/identifier[text()[1] = "call"]]
                        [callArguments//stringLiteral[string-length(text()) = 0]]
                        [callArguments/tupleExpression[count(expression) = 1]]
                        [not(gas/expression)]
                </XPath>
            </Pattern>
            <!-- Looks for low-level call() with empty data (""), but with gas limit. -->
            <!-- Фиксирует вызовы call с пустой датой (""), но с ограничением газа. -->
            <Pattern patternId="111ttt">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //functionCall
                        [functionName/identifier[text()[1] = "call"]]
                        [callArguments//stringLiteral[string-length(text()) = 0]]
                        [callArguments/tupleExpression[count(expression) = 1]]
                        [gas/expression]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_DELETE_ON_DYNAMIC_ARRAYS</RuleId>
        <Patterns>
            <!-- Looks for delete or `.length = 0` on dynamically-sized storage arrays. -->
            <!-- Фиксирует delete или `.length = 0`, примененное к массивам с динамической длиной, лежащим в storage контракта. -->
            <Pattern patternId="2ft3g5">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //(
                        deleteStatement
                        | expression
                            [matches(text()[1], "^=$")]
                            [expression[2]//numberLiteral/decimalNumber/text()[1] = "0"]
                            /expression[1][matches(text()[1], "^\.length$")]
                    )
                        [
                            expression/primaryExpression/identifier
                                = ancestor::contractDefinition/contractPartDefinition/stateVariableDeclaration
                                    [
                                        typeName[text()[1] = "[]"] or
                                        typeName/elementaryTypeName
                                            [
                                                text()[1] = "bytes" or
                                                text()[1] = "string"
                                            ]
                                    ]/identifier
                        ]
                </XPath>
            </Pattern>
            <!-- Looks for delete or `.length = 0` on dynamically-sized storage arrays passed as reference in function. -->
            <!-- Фиксирует delete или `.length = 0`, примененное к массивам с динамической длиной, переданным в виде аргумента функции. -->
            <Pattern patternId="6f23y5">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //(
                        deleteStatement
                        | expression
                            [matches(text()[1], "^=$")]
                            [expression[2]//numberLiteral/decimalNumber/text()[1] = "0"]
                            /expression[1][matches(text()[1], "^\.length$")]
                    )
                        [
                            expression/primaryExpression/identifier
                                = ancestor::functionDefinition/parameterList/parameter
                                    [storageLocation[text()[1] = "storage"]]/identifier
                        ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_DEPRECATED_CONSTRUCTIONS</RuleId>
        <Patterns>
            <!-- Looks for "suicide". -->
            <!-- Фиксирует конструкцию: "suicide". -->
            <Pattern patternId="27cb59">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //functionCall/functionName//identifier[matches(text()[1], "^suicide$")]
                    | //assemblyCall/identifier[matches(text()[1], "^suicide$")]
                </XPath>
            </Pattern>
            <!-- Looks for "sha3". -->
            <!-- Фиксирует конструкцию: "sha3". -->
            <Pattern patternId="187b5a">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //functionCall/functionName//identifier[matches(text()[1], "^sha3$")]
                    | //assemblyCall/identifier[matches(text()[1], "^sha3$")]
                </XPath>
            </Pattern>
            <!-- Looks for "throw". -->
            <!-- Фиксирует конструкцию: "throw". -->
            <Pattern patternId="49bd2a">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //statement/throwRevertStatement[matches(text()[1], "^throw$")]
                </XPath>
            </Pattern>
            <!-- Looks for using "constant" keyword for functions. -->
            <!-- Фиксирует использование типа constant в определении функции. -->
            <Pattern patternId="28fa69">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //functionDefinition[stateMutability/constantType]
                </XPath>
            </Pattern>
            <!-- Looks for "years" multiplier. -->
            <!-- Фиксирует использование множителя years. -->
            <Pattern patternId="852kwn">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //numberLiteral/numberUnit[text()[1] = "years"]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_DIV_MUL</RuleId>
        <Patterns>
            <!-- Looks for arithmetic expressions with division before multiplication, including those using SafeMath library. -->
            <!--Фиксирует арифметические операции в которых деление перед(ниже по дереву) умножением, в том числе с использованием SafeMath. -->
            <Pattern patternId="09hhh1">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //expression
                        [
                            muldivOperator/mulOperator
                            or functionCall/functionName/identifier[text()[1] = "mul"]
                        ]
                        [
                            descendant::divOperator
                            or descendant::functionCall/functionName/identifier[text()[1] = "div"]
                        ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_DO_WHILE_CONTINUE</RuleId>
        <Patterns>
            <!-- Looks for "continue" inside do-while loop in files compiled with solidity 0.4 and older. -->
            <!--Фиксирует конструкцию: do {continue;} while (false); в версиях компилятора ниже 0.5.0 инструкция continue переводит исполнение на do, не проверяя условие в while - это делает цикл do while бесконечным. -->
            <Pattern patternId="94fra3">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    /sourceUnit[pragmaDirective
                        [not(//versionOperator) or //versionOperator[text()[1] = "^"]]
                        [//versionLiteral[not(matches(text()[1], "^0\.\s*[5-9]\s*\.|^0\.\s*[0-9]{2,}\s*\.|^[1-9]"))]]]
                    //doWhileStatement
                        [statement//continueStatement
                            [
                                not(ancestor::forStatement[ancestor::doWhileStatement])
                                and not(ancestor::whileStatement[ancestor::doWhileStatement])
                            ]
                        ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_DOS_WITH_THROW</RuleId>
        <Patterns>
            <!-- пока отключаем / disabled -->
            <!-- Looks for construction: "if (... external call ...) {throw, revert}". -->
            <!-- Фиксирует конструкцию: "if (... внешний вызов ...) {throw, revert}". -->
            <!-- <Pattern patternId="637fdc">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>3</Severity>
                <XPath>//ifStatement[condition//externalFunctionCall][block/statement//throwRevertStatement]</XPath>
            </Pattern> -->
            <!-- пока отключаем / disabled -->
            <!-- Looks for construction: "for (... external call ...)". -->
            <!-- Фиксирует конструкцию: "for (... внешний вызов ...)". -->
            <!-- <Pattern patternId="efb788">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>//forStatement/expression//externalFunctionCall</XPath>
            </Pattern> -->
            <!-- пока отключаем / disabled -->
            <!-- Looks for construction: "while (... externall call ...)". -->
            <!-- Фиксирует конструкцию: "while (... внешний вызов ...)". -->
            <!-- <Pattern patternId="04242c">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>//whileStatement/whileCondition//externalFunctionCall</XPath>
            </Pattern> -->
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_ERC20_APPROVE</RuleId>
        <Patterns>
            <!-- Looks for non-empty "approve" function in a contract with name that contains "token" or "erc20", or the contract's parent has such name. -->
            <!-- Фиксирует конструкции: имя контракта содержит token или erc20 либо наследуется от контракта содержащего такое в названии. В этом контракте есть определение функции approve, которая не является интерфейсом. -->
            <Pattern patternId="af782c">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //contractDefinition
                        [
                            identifier[matches(text()[1], "token|erc20", "i")]
                            or inheritanceSpecifier/userDefinedTypeName/identifier[matches(text()[1], "token|erc20", "i")]
                        ]
                        //functionDefinition
                            [block/statement]
                            [identifier[matches(text()[1], "^approve$")]]
                            [not(
                                ancestor::contractDefinition//functionDefinition
                                [block/statement]
                                [identifier[matches(text()[1], "Approval$|Allowance$|Approve$")]]
                            )
                            ]
                </XPath>
            </Pattern>
            <!-- Looks for non-empty "approve" function in a contract with name that contains "token" or "erc20", or the contract's parent has such name.
                 In case the contract contains `decrease-/icreaseApproval`, etc. implemented - severity is low -->
            <!-- Фиксирует конструкции: имя контракта содержит token или erc20 либо наследуется от контракта содержащего такое в названии. В этом контракте есть определение функции approve, которая не является интерфейсом.
                 В случае, когда в контракте есть функции `decrease-/icreaseApproval` и им подобные, снижена критичность -->
            <Pattern patternId="lsd05g">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //contractDefinition
                        [
                            identifier[matches(text()[1], "token|erc20", "i")]
                            or inheritanceSpecifier/userDefinedTypeName/identifier[matches(text()[1], "token|erc20", "i")]
                        ]
                        //functionDefinition
                            [block/statement]
                            [identifier[matches(text()[1], "^approve$")]]
                            [ancestor::contractDefinition//functionDefinition
                                [block/statement]
                                [identifier[matches(text()[1], "Approval$|Allowance$|Approve$")]]
                            ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_ERC20_FUNCTIONS_ALWAYS_RETURN_FALSE</RuleId>
        <Patterns>
            <!-- Looks for construction: contract's name contains "token" or "erc20", or parent contract contains such name. In this contract there is definition of transfer, transferFrom or approve function, which returns value of type bool and is not an interface.
            There is no return or assignment of the return parameter in the definition of such function. -->
            <!--Фиксирует конструкции: имя контракта содержит token или erc20 либо наследуется от контракта содержащего такое в названии.
            В этом контракте есть определение функции с названием transfer,transferFrom или approve, которая возвращающает значение типа bool и не является интерфейсом.
            В определении этой функции не содержится return или присваивание возвращаемого параметра. -->
            <Pattern patternId="b180ca">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //contractDefinition
                        [
                            identifier[matches(text()[1], "token|erc20", "i")]
                            or inheritanceSpecifier/userDefinedTypeName/identifier[matches(text()[1], "token|erc20", "i")]
                        ]
                    //functionDefinition
                        [block/statement]
                        [identifier[matches(text()[1], "^transfer$|^transferFrom$|^approve$")]]
                        [returnsParameters/parameterList/parameter/typeName/elementaryTypeName[matches(text()[1], "bool")]]
                        [not(block/statement//returnStatement)]
                        [count(returnsParameters/parameterList/parameter) = 1]
                        [
                            returnsParameters/parameterList/parameter/identifier
                                [not(text()[1]
                                    = ancestor::functionDefinition/block//expression
                                        [matches(text()[1], "=")]/expression[1]//identifier)
                                ]
                            or returnsParameters/parameterList/parameter[not(identifier)]
                        ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_ERC20_INDEXED</RuleId>
        <Patterns>
            <!-- Looks for Transfer and Approval events in ERC20 tokens without indexed address parameters. -->
            <!-- Фиксирует коснтрукции в ERC20 токенах: Transfer, Approval события с не идексированными переменными типа address. -->
            <Pattern patternId="ac081b">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    <!-- looks for Transfer and Aproval events -->
                    //eventDefinition[identifier[text()[1] = "Transfer" or text()[1] = "Approval"]]
                    <!-- with unindexed address parameter -->
                        [
                            indexedParameterList/indexedParameter
                                [typeName/elementaryTypeName[text()[1] = "address"]]
                                [not(text()[1] = "indexed")]
                        ]
                    <!-- check that event has three parameters -->
                        [indexedParameterList[count(child::indexedParameter) = 3]
                    <!-- check that there are two address parameters in the event -->
                        [count(child::indexedParameter//elementaryTypeName[text()[1] = "address"]) = 2]
                    <!-- check that there is one uint256 parameter in the event -->
                        [count(child::indexedParameter//elementaryTypeName[text()[1] = "uint256"]) = 1]]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_ERC20_TRANSFER_SHOULD_THROW</RuleId>
        <Patterns>
            <!-- Looks for construction: contract's name contains token or erc20, or parent contract contains such name. In this contract there is a  definition of transfer, transferFrom or approve function, which returns value of type bool and is not an interface.
            There are no revert(), require(), assert(), throw and function call in the definition of such function. -->
            <!--Фиксирует конструкции: имя контракта содержит token или erc20 либо наследуется от контракта содержащего такое в названии.
             В этом контракте есть определение функции, содержащей в названии transfer или transferFrom, возвращающей значение типа bool, которая не является интерфейсом.
             В определении этой функции не содержатся функции revert, require, assert, throw, кроме того нет любых вызовов функций-->
            <Pattern patternId="550a42">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //contractDefinition
                    [
                        identifier[matches(text()[1], "token|erc20", "i")]
                        or inheritanceSpecifier/userDefinedTypeName/identifier[matches(text()[1], "token|erc20", "i")]
                    ]
                    //functionDefinition
                        [block/statement]
                        [identifier[matches(text()[1], "^transfer(From)?$")]]
                        [returnsParameters/parameterList/parameter/typeName/elementaryTypeName[matches(text()[1], "bool")]]
                        [count(descendant-or-self::*[functionCall]
                            | descendant-or-self::*[statement/throwRevertStatement]) = 0
                        ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_EXACT_TIME</RuleId>
        <Patterns>
            <!-- Looks for expression that contains "==" or "!=" and "block.timestamp" or "now", except for cases when timestamp is a function argument. -->
            <!-- Фиксируется случаи, когда выражение содержит "== or != block.timestamp or now", кроме функций от now/block.timestamp. -->
            <Pattern patternId="1955d9">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //expression
                        [comparison]
                        [expression//environmentalVariable
                            [matches(text()[1], "^block\.timestamp|now$")]
                            [not(ancestor::*[4][self::functionCall])]]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_EXTRA_GAS_IN_LOOPS</RuleId>
        <Patterns>
            <!-- Looks for "for" loop, which accesses contract's state variables. -->
            <!-- Фиксирует циклы for, в которых во 2 или 3 стейтменте есть стейт переменные контракта.-->
            <Pattern patternId="d3j11j">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //forStatement
                        [
                            (condition | expression[2])/expression/expression[not(matches(text()[1], "^\.balance$|^\.length$"))]//identifier
                                = ancestor::contractDefinition//stateVariableDeclaration[not(constantType)]/identifier
                        ]
                </XPath>
            </Pattern>
            <!-- Looks for "for" loop, which accesses ".balance" in second or third statement. -->
            <!-- Фиксирует циклы for, в которых во 2 или 3 стейтменте есть ".balance". -->
            <Pattern patternId="5f8g1j">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //forStatement[(condition | expression[2])//expression[matches(text()[1], "^\.balance$")]]
                </XPath>
            </Pattern>
            <!-- Looks for "for" loop, which accesses ".length" in second or third statement. -->
            <!-- Фиксирует циклы for, в которых во 2 или 3 стейтменте есть ".length". -->
            <Pattern patternId="v843m7">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //forStatement
                        [   <!-- 2nd or 3rd part contains '.length' expression -->
                            (condition | expression[2])//expression
                                [matches(text()[1], "^\.length$")]
                                <!-- and array is neither public function argument -->
                                [
                                    not(expression//text()[1]
                                        = ancestor::functionDefinition
                                            [
                                                visibleType[matches(text()[1], "^public$")]
                                                or not(visibleType)
                                            ]//parameter/identifier/text()
                                    )
                                ]
                                <!-- nor internal or private function argument with memory visibility modifier -->
                                [
                                    not(expression//text()[1]
                                        = ancestor::functionDefinition
                                            [visibleType[matches(text()[1], "^private$|^internal$")]]
                                            //parameter[storageLocation/text() = "memory"]/identifier/text()
                                    )
                                ]
                                <!-- nor copied to local variable with memory visibility modifier -->
                                [
                                    not(expression//text()[1]
                                        = ancestor::functionDefinition
                                            //variableDeclaration[storageLocation/text() = "memory"]/identifier/text()
                                    )
                                ]
                        ]
                </XPath>
            </Pattern>
            <!-- Looks for "while" loop, which condition accesses contract's state variables. -->
            <!-- Фиксирует циклы while, в которых в условии есть стейт переменные контракта. -->
            <Pattern patternId="k4o1l4">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //whileStatement
                        [
                            condition/expression/expression
                                [not(matches(text()[1], "^\.balance$|^\.length$"))]//identifier
                                = ancestor::contractDefinition//stateVariableDeclaration[not(constantType)]/identifier
                        ]
                </XPath>
            </Pattern>
            <!-- Looks for "while" loop, which condition accesses ".balance". -->
            <!-- Фиксирует циклы while, в которых в условии есть ".balance". -->
            <Pattern patternId="1f6n9l">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //whileStatement[condition//expression[matches(text()[1], "^\.balance$")]]
                </XPath>
            </Pattern>
            <!-- Looks for "while" loop, which condition accesses ".length". -->
            <!-- Фиксирует циклы while, в которых в условии есть ".length". -->
            <Pattern patternId="v94c8j">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //whileStatement
                        [   <!-- condition contains '.length' expression -->
                            condition//expression
                                [matches(text()[1], "^\.length$")]
                                <!-- and array is neither public function argument -->
                                [
                                    not(expression//text()[1]
                                        = ancestor::functionDefinition
                                            [
                                                visibleType[matches(text()[1], "^public$")]
                                                or not(visibleType)
                                            ]//parameter/identifier/text()
                                    )
                                ]
                                <!-- nor internal or private function argument with memory visibility modifier -->
                                [
                                    not(expression//text()[1]
                                        = ancestor::functionDefinition
                                            [visibleType[matches(text()[1], "^private$|^internal$")]]
                                            //parameter[storageLocation/text() = "memory"]/identifier/text()
                                    )
                                ]
                                <!-- nor copied to local variable with memory visibility modifier -->
                                [
                                    not(expression//text()[1]
                                        = ancestor::functionDefinition
                                            //variableDeclaration[storageLocation/text() = "memory"]/identifier/text()
                                    )
                                ]
                        ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
    <RuleId>SOLIDITY_FUNCTION_RETURNS_TYPE_AND_NO_RETURN</RuleId>
    <Patterns>
        <!-- Looks for functions with unnamed return parameters and without return statement. -->
        <!-- Фиксирует функции, у которых есть возвращаемые параметры без идентификатора(returns(uint,...)), и в теле функции нет return. -->
        <Pattern patternId="47acc2">
            <Categories>
                <Category>Solidity</Category>
            </Categories>
            <Severity>1</Severity>
            <XPath>
                //functionDefinition
                    [block]
                    [returnsParameters/parameterList/parameter[not(identifier)]]
                    [
                        not(block/statement//returnStatement)
                        and not(block//assemblyCall[matches(text()[1], "^return\(")])
                    ]
            </XPath>
        </Pattern>
        <!-- Looks for construction: "function(...) ... returns (type name) {...}" and there are no assignment "name=" and no return. -->
        <!-- Фиксирует конструкцию: "function(...) ... returns (type name) {...}" - в теле функции нет присваивания "name=" и нет return. -->
        <Pattern patternId="58bdd3">
            <Categories>
                <Category>Solidity</Category>
            </Categories>
            <Severity>1</Severity>
            <XPath>
                //functionDefinition
                    [block]
                    [
                        not(block/statement//returnStatement)
                        and not(block//assemblyCall[matches(text()[1], "^return\(")])
                    ]
                    [returnsParameters/parameterList/parameter/identifier
                        [
                            not(text()[1]
                                = (ancestor::functionDefinition/block//expression
                                    [matches(text()[1], "=")]/expression[1]//identifier/text()[1]))
                            and not(text()[1]
                                = ancestor::functionDefinition/block
                                    //assemblyAssignment/assemblyIdentifierOrList//identifier/text()[1])
                        ]
                    ]
            </XPath>
        </Pattern>
    </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_GAS_LIMIT_IN_LOOPS</RuleId>
        <Patterns>
            <!-- Looks for construction: "for (<counter is initialized as zero>; <counter is lower than name.length>; ...)", name is not in memory. -->
            <!-- Фиксирует конструкцию: "for (<инициализация счетчика нулём>; <счетчик меньше чем name.length>; ...)", name не находится в memory. -->
            <Pattern patternId="f6f853">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //forStatement
                        [   <!-- i = 0; -->
                            expression[1][text()[1] = "="]/expression[2]//numberLiteral/decimalNumber[text()[1] = "0"]
                            <!-- uint i = 0; -->
                            or expression[1]/variableDeclaration[text()[1] = "="]/expression//numberLiteral/decimalNumber[text()[1] = "0"]
                            <!-- uint i; -->
                            or expression[1]/variableDeclaration[not(text()[1] = "=")]
                        ]
                        [   <!-- ".length" in condition and base is not in memory -->
                            condition/expression[matches(text()[1], "&lt;|&lt;=")]/expression[2][text()[1] = ".length"]/expression/primaryExpression/identifier
                                <!-- and array is neither public or external function argument -->
                                [not(text()[1] = ancestor::functionDefinition[visibleType[matches(text()[1], "^public$|^external$")] or not(visibleType)]//parameter/identifier/text())]
                                <!-- nor internal or private function argument with memory visibility modifier -->
                                [not(text()[1] = ancestor::functionDefinition[visibleType[matches(text()[1], "^private$|^internal$")]]//parameter[storageLocation/text() = "memory"]/identifier/text())]
                                <!-- nor copied to local variable with memory visibility modifier -->
                                [not(text()[1] = ancestor::functionDefinition//variableDeclaration[storageLocation/text() = "memory"]/identifier/text())]
                            <!-- may be a variable in condition and it is ... -->
                            or condition/expression[matches(text()[1], "&lt;|&lt; =")]/expression[2]/primaryExpression/identifier
                                [   <!-- new variable with non-memory array length -->
                                    text()[1] = (ancestor::functionDefinition//variableDeclaration[text()[1] = "="]
                                        [expression[text()[1] = ".length"]/expression/primaryExpression/identifier
                                            <!-- and array is neither public or external function argument -->
                                            [not(text()[1] = ancestor::functionDefinition[visibleType[matches(text()[1], "^public$|^external$")] or not(visibleType)]//parameter/identifier/text())]
                                            <!-- nor internal or private function argument with memory visibility modifier -->
                                            [not(text()[1] = ancestor::functionDefinition[visibleType[matches(text()[1], "^private$|^internal$")]]//parameter[storageLocation/text() = "memory"]/identifier/text())]
                                            <!-- nor copied to local variable with memory visibility modifier -->
                                            [not(text()[1] = ancestor::functionDefinition//variableDeclaration[storageLocation/text() = "memory"]/identifier/text())]
                                        ]/identifier/text()[1])
                                    <!-- or reused variable with non-memory array length -->
                                    or text()[1] = (ancestor::functionDefinition//expression[text()[1] = "="]
                                        [expression[2][text()[1] = ".length"]/expression/primaryExpression/identifier
                                            <!-- and array is neither public or external function argument -->
                                            [not(text()[1] = ancestor::functionDefinition[visibleType[matches(text()[1], "^public$|^external$")] or not(visibleType)]//parameter/identifier/text())]
                                            <!-- nor internal or private function argument with memory visibility modifier -->
                                            [not(text()[1] = ancestor::functionDefinition[visibleType[matches(text()[1], "^private$|^internal$")]]//parameter[storageLocation/text() = "memory"]/identifier/text())]
                                            <!-- nor copied to local variable with memory visibility modifier -->
                                            [not(text()[1] = ancestor::functionDefinition//variableDeclaration[storageLocation/text() = "memory"]/identifier/text())]
                                        ]/expression[1]//identifier/text()[1])
                                ]
                        ]
                </XPath>
            </Pattern>
            <!-- Looks for construction: "for (<counter is initialized as zero>; <counter is lower than name.length>; ...)", name in memory. -->
            <!-- Фиксирует конструкцию: "for (<инициализация счетчика нулём>; <счетчик меньше чем name.length>; ...)" name находится в memory. -->
            <Pattern patternId="4b7do5">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //forStatement
                        [   <!-- i = 0; -->
                            expression[1][text()[1] = "="]/expression[2]//numberLiteral/decimalNumber[text()[1] = "0"]
                            <!-- uint i = 0; -->
                            or expression[1]/variableDeclaration[text()[1] = "="]/expression//numberLiteral/decimalNumber[text()[1] = "0"]
                            <!-- uint i; -->
                            or expression[1]/variableDeclaration[not(text()[1] = "=")]
                        ]
                        [   <!-- ".length" in condition and base is in memory -->
                            condition/expression[matches(text()[1], "&lt;|&lt;=")]/expression[2][text()[1] = ".length"]/expression/primaryExpression/identifier
                                [   <!-- and array is either public or external function argument -->
                                    text()[1] = ancestor::functionDefinition[visibleType[matches(text()[1], "^public$|^external$")] or not(visibleType)]//parameter/identifier/text()
                                    <!-- or internal or private function argument with memory visibility modifier -->
                                    or text()[1] = ancestor::functionDefinition[visibleType[matches(text()[1], "^private$|^internal$")]]//parameter[storageLocation/text() = "memory"]/identifier/text()
                                    <!-- or copied to local variable with memory visibility modifier -->
                                    or text()[1] = ancestor::functionDefinition//variableDeclaration[storageLocation/text() = "memory"]/identifier/text()
                                ]
                            <!-- may be a variable in condition and it is ... -->
                            or condition/expression[matches(text()[1], "&lt;|&lt;=")]/expression[2]/primaryExpression/identifier
                                [   <!-- new variable with memory array length -->
                                    text()[1] = (ancestor::functionDefinition//variableDeclaration[text()[1] = "="]
                                        [expression[text()[1] = ".length"]/expression/primaryExpression/identifier
                                            [   <!-- and array is either public or external function argument -->
                                                text()[1] = ancestor::functionDefinition[visibleType[matches(text()[1], "^public$|^external$")] or not(visibleType)]//parameter/identifier/text()
                                                <!-- or internal or private function argument with memory visibility modifier -->
                                                or text()[1] = ancestor::functionDefinition[visibleType[matches(text()[1], "^private$|^internal$")]]//parameter[storageLocation/text() = "memory"]/identifier/text()
                                                <!-- or copied to local variable with memory visibility modifier -->
                                                or text()[1] = ancestor::functionDefinition//variableDeclaration[storageLocation/text() = "memory"]/identifier/text()
                                            ]
                                        ]/identifier/text()[1])
                                    <!-- or reused variable with memory array length -->
                                    or text()[1] = (ancestor::functionDefinition//expression[text()[1] = "="]
                                        [expression[2][text()[1] = ".length"]/expression/primaryExpression/identifier
                                            [   <!-- and array is either public or external function argument -->
                                                text()[1] = ancestor::functionDefinition[visibleType[matches(text()[1], "^public$|^external$")] or not(visibleType)]//parameter/identifier/text()
                                                <!-- or internal or private function argument with memory visibility modifier -->
                                                or text()[1] = ancestor::functionDefinition[visibleType[matches(text()[1], "^private$|^internal$")]]//parameter[storageLocation/text() = "memory"]/identifier/text()
                                                <!-- or copied to local variable with memory visibility modifier -->
                                                or text()[1] = ancestor::functionDefinition//variableDeclaration[storageLocation/text() = "memory"]/identifier/text()
                                            ]
                                        ]/expression[1]//identifier/text()[1])
                                ]
                        ]
                </XPath>
            </Pattern>
            <!-- Looks for construction: "for (<counter is initialized as name.length>; <counter is bigger than anything>; ...)", name is not in memory. -->
            <!-- Фиксирует конструкцию: "for (<инициализация счетчика name.length>; <счетчик больше чем что угодно>; ...)", name не находится в memory. -->
            <Pattern patternId="12cf32">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //forStatement
                        [
                            (   <!-- either reused variable with .length in pre-condition -->
                                expression[1][text()[1] = "="]/expression[2][text()[1] = ".length"]/expression/primaryExpression/identifier
                                <!-- or new variable with .length in pre-condition -->
                                | expression[1]/variableDeclaration[text()[1] = "="]/expression[text()[1] = ".length"]/expression/primaryExpression/identifier
                            )
                            <!-- and array is neither public or external function argument -->
                            [not(text()[1] = ancestor::functionDefinition[visibleType[matches(text()[1], "^public$|^external$")] or not(visibleType)]//parameter/identifier/text())]
                            <!-- nor internal or private function argument with memory visibility modifier -->
                            [not(text()[1] = ancestor::functionDefinition[visibleType[matches(text()[1], "^private$|^internal$")]]//parameter[storageLocation/text() = "memory"]/identifier/text())]
                            <!-- nor copied to local variable with memory visibility modifier -->
                            [not(text()[1] = ancestor::functionDefinition//variableDeclaration[storageLocation/text() = "memory"]/identifier/text())]
                        ]
                        [condition/expression[matches(text()[1], "&gt;|&gt;=")]]
                </XPath>
            </Pattern>
            <!-- Looks for construction: "for (<counter is initialized as name.length>; <counter is bigger than anything>; ...)", name is in memory. -->
            <!-- Фиксирует конструкцию: "for (<инициализация счетчика name.length>; <счетчик больше чем что угодно>; ...)", name находится в memory. -->
            <Pattern patternId="v5j3d9">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //forStatement
                    [
                        (   <!-- either reused variable with .length in pre-condition -->
                            expression[1][text()[1] = "="]/expression[2][text()[1] = ".length"]/expression/primaryExpression/identifier
                            <!-- or new variable with .length in pre-condition -->
                            | expression[1]/variableDeclaration[text()[1] = "="]/expression[text()[1] = ".length"]/expression/primaryExpression/identifier
                        )
                        [   <!-- and array is either public or external function argument -->
                            text()[1] = ancestor::functionDefinition[visibleType[matches(text()[1], "^public$|^external$")] or not(visibleType)]//parameter/identifier/text()
                            <!-- or internal or private function argument with memory visibility modifier -->
                            or text()[1] = ancestor::functionDefinition[visibleType[matches(text()[1], "^private$|^internal$")]]//parameter[storageLocation/text() = "memory"]/identifier/text()
                            <!-- or copied to local variable with memory visibility modifier -->
                            or text()[1] = ancestor::functionDefinition//variableDeclaration[storageLocation/text() = "memory"]/identifier/text()
                        ]
                    ]
                    [condition/expression[matches(text()[1], "&gt;|&gt;=")]]
                </XPath>
            </Pattern>
            <!-- Looks for construction: "while (<condition>)" where <condition> doesn't include function call or specific expression with number. -->
            <!-- Фиксируется конструкция: "while (в условии все, кроме вызова функции и числа)". -->
            <Pattern patternId="17f23a">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //whileStatement/condition
                        [
                            not(descendant-or-self::functionCall)
                            and not(expression/expression/primaryExpression/numberLiteral/decimalNumber)
                        ]
                </XPath>
            </Pattern>
            <!-- Looks for construction: "while (<function call>)".-->
            <!-- Фиксируется конструкция: "while (в условии вызов функции)".-->
            <Pattern patternId="38f6c7">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //whileStatement[condition/descendant::functionCall]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_INCORRECT_BLOCKHASH</RuleId>
        <Patterns>
            <!-- Looks for incorrect use of blockhash: blockhash(<number>), blockhash(block.number). -->
            <!-- Фиксирует неправильное использование blockhash: blockhash(число), blockhash(block.number) - не известен хэш текущего блока, blockhash(block.number минус число больше 256) - храняться хэши только последних 256 блоков. -->
            <Pattern patternId="b629ad">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //environmentalVariable
                        [matches(text()[1], "^block\.blockhash\($|^blockhash\($")]
                    /expression
                        [
                            primaryExpression/numberLiteral/decimalNumber
                            or environmentalVariable[text()[1] = "block.number"]
                            or (
                                expression[1]/environmentalVariable[text()[1] = "block.number"]
                                and plusminusOperator
                                and expression[2]/primaryExpression/numberLiteral/decimalNumber
                                    [text()[1] > 256]
                            )
                        ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_LOCKED_MONEY</RuleId>
        <Patterns>
            <!-- Looks for situations, where there is a payable function in the contract, however there is no "suicide", "selfdestruct", "delegatecall", "transfer", "send", or ".value". -->
            <!-- Фиксируются ситуации, когда в контракте имеется функция типа payable, но нет функций "suicide", "selfdestruct", "delegatecall", "transfer", "send", ".value". -->
            <Pattern patternId="30281d">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>3</Severity>
                <XPath>
                    //contractDefinition
                        [contractPartDefinition
                            [
                                functionDefinition/stateMutability/payableType
                                or functionFallBackDefinition/stateMutability/payableType
                            ]
                        ]
                        [not(contractPartDefinition/functionDefinition/block//functionCall/functionName//identifier
                            [matches(text()[1], "^suicide$|^selfdestruct$")])]
                        [not(contractPartDefinition/functionDefinition/block//functionCall/functionName//identifier
                            [matches(text()[1], "^transfer$|^send$")])]
                        [not(contractPartDefinition/functionDefinition/block//functionCall/functionName//identifier
                            [matches(text()[1], "^delegatecall$")])]
                        [not(contractPartDefinition/functionDefinition/block//functionCall/value)]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_MSGVALUE_EQUALS_ZERO</RuleId>
        <Patterns>
            <!-- Looks for checks (msg.value == 0), except for those in the conctructor. -->
            <!-- Фиксируются проверки (msg.value == 0) везде, кроме конструктора. -->
            <Pattern patternId="1df89a">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //expression
                        [expression[1]/environmentalVariable[text()[1] = "msg.value"]]
                        [comparison[text()[1] = "=="]]
                        [expression[2]/primaryExpression//decimalNumber[text()[1] = "0"]]
                        [not(ancestor::functionDefinition[text()[1] = "constructor"])]
                        [not(ancestor::functionDefinition/identifier[text()[1]
                            = (ancestor::contractDefinition/identifier)])
                        ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_OVERPOWERED_ROLE</RuleId>
        <Patterns>
            <!-- Looks for functions with input parameter(s), named like "set*" or "init*", that have onlyOwner() modifier or compare msg.sender to some specific address.-->
            <!-- Фиксируются функции с входными параметрами, с модификатором onlyOwner() или содержащие проверку (msg.sender==owner) (owner тут это любой адрес контракта) и названием начинающимся на set* или init*. -->
            <Pattern patternId="j83hf7">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //functionDefinition
                        [parameterList/parameter]
                        [
                            identifier[text()[1] = "onlyOwner"]
                            or identifier[text()[1] = "onlyOwner()"]
                            or descendant::expression
                                [comparison[text()[1] = "=="]]
                                [expression/environmentalVariable[text()[1] = "msg.sender"]]
                                [expression/primaryExpression/identifier
                                    [text()[1] =
                                        ancestor::contractDefinition//stateVariableDeclaration
                                            [typeName/elementaryTypeName[text()[1] = "address"]]/identifier/text()[1]
                                    ]
                                ]
                        ]
                        [identifier[matches(text()[1], "^set|^init")]]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_PRAGMAS_VERSION</RuleId>
        <Patterns>
            <!-- Looks for pragma version, which contains '^' | '>=' | '>' | '<' | '<='. -->
            <!-- Фиксируется определение pragma имеющее в версии знаки '^' | '>=' | '>' | '<' | '<='. -->
            <Pattern patternId="23fc32">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //pragmaDirective/pragmaSolidity//versionOperator
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_PRIVATE_MODIFIER_DOES_NOT_HIDE_DATA</RuleId>
        <Patterns>
            <!-- Looks for state variables with private visibility type. -->
            <!-- Фиксируется определение state переменных с типом видимости private-->
            <Pattern patternId="5616b2">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //stateVariableDeclaration/visibleType[text()[1] = "private"]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_REDUNDANT_FALLBACK_REJECT</RuleId>
        <Patterns>
            <!-- Looks for cases, when comiler's version is equal or bigger than 0.4.0, contract contains payable fallback() function with only one statement in the definition: throw or revert(). -->
            <!--Фиксируется случаи, когда версия компилятора больше или равна 0.4.0, контракт содержит fallback функцию типа payable, в определении которой есть только один statement: throw или revert(). -->
            <Pattern patternId="b85a32">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //sourceUnit
                        [pragmaDirective/pragmaSolidity/version[versionLiteral &gt;= "0.4.0"]]
                        /contractDefinition/contractPartDefinition/functionFallBackDefinition/block
                            [count(descendant-or-self::statement) = 1]
                            [statement/throwRevertStatement]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_REVERT_REQUIRE</RuleId>
        <Patterns>
            <!-- Looks for construction: "if (...){revert(); or throw;}". -->
            <!-- Фиксирует конструкцию: "if (...){revert(); или throw;}". -->
            <Pattern patternId="c56b12">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //ifStatement[statement[not(descendant::ifStatement)]//throwRevertStatement]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_REWRITE_ON_ASSEMBLY_CALL</RuleId>
        <Patterns>
            <!-- Looks for assembly CALL family instruction, which rewrites the input with the output. -->
            <!-- Фиксирует вызов инструкции семейства CALL, которая перезаписывает входные данные возвращаемыми. -->
            <Pattern patternId="f34j6k">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //assemblyItem
                        [
                            assemblyLocalDefinition/assemblyExpression/assemblyCall
                                [
                                    count(assemblyExpression) = 6
                                    and assemblyExpression[3]/assemblyCall/identifier/text()[1]
                                        = assemblyExpression[5]/assemblyCall/identifier/text()[1]
                                    or count(assemblyExpression) = 7
                                    and assemblyExpression[4]/assemblyCall/identifier/text()[1]
                                        = assemblyExpression[6]/assemblyCall/identifier/text()[1]
                                ]
                            /identifier
                                [matches(text()[1], "^call$|^staticcall$|^callcode$|^delegatecall$")]
                        ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_SAFEMATH</RuleId>
        <Patterns>
            <!-- Looks for usage of SafeMath library. -->
            <!-- Фиксирует использование библиотеки SafeMath. -->
            <Pattern patternId="837cac">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //usingForDeclaration[identifier[matches(text()[1], "^SafeMath$", "i")]]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_SEND</RuleId>
        <Patterns>
            <!-- Looks for using of send function in the following cases: if (<addr>.send(value)){revert() or throw}, and require or assert with send as an argument. -->
            <!-- Фиксируется использование функции send, в случаях: if (<addr>.send(value)){revert() или throw}, и require или assert от send. -->
            <Pattern patternId="430636">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //expression
                        [text()[1] = "."]
                        [not(expression[1]/typeConversion/typeName/elementaryTypeName[matches(text()[1], "^address$|^address payable$")])]
                        /functionCall
                            [functionName/identifier[text()[1] = "send"]]
                            [callArguments/tupleExpression[count(expression) = 1]]
                            [
                                ancestor::condition
                                    [expression/text()[1] = "!"]
                                    /parent::ifStatement/statement/block/statement/throwRevertStatement
                                or ancestor::functionCall
                                    [not(callArguments/tupleExpression/expression/text()[1] = "!")]
                                    /functionName/identifier
                                        [matches(text()[1], "^require$|^assert$")]
                            ]
                </XPath>
            </Pattern>
            <!-- Looks for using of send function in the following cases: if (address[ payable](<addr>).send(value)){revert() or throw}, and require or assert with send as an argument. -->
            <!-- Фиксируется использование функции send, в случаях: if (address[ payable](<addr>).send(value)){revert() или throw}, и require или assert от send. -->
            <Pattern patternId="we5gu5">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //expression
                        [text()[1] = "."]
                        [expression[1]/typeConversion/typeName/elementaryTypeName[matches(text()[1], "^address$|^address payable$")]]
                        /functionCall
                            [functionName/identifier[text()[1] = "send"]]
                            [callArguments/tupleExpression[count(expression) = 1]]
                            [
                                ancestor::condition
                                    [expression/text()[1] = "!"]
                                    /parent::ifStatement/statement/block/statement/throwRevertStatement
                                or ancestor::functionCall
                                    [not(callArguments/tupleExpression/expression/text()[1] = "!")]
                                    /functionName/identifier
                                        [matches(text()[1], "^require$|^assert$")]
                            ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_SHOULD_NOT_BE_PURE</RuleId>
        <Patterns>
            <Pattern patternId="11314f">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //functionDefinition
                        [
                            stateMutability/pureType
                            and block/descendant-or-self::*
                                [   <!--Accessing <address>.balance: using .balance-->
                                    expression[matches(text()[1], "\.balance")]
                                    <!--Accessing any of the members of block, tx, msg (with the exception of msg.sig and msg.data)-->
                                    or environmentalVariable[matches(text()[1], "msg\.value|msg\.gas|msg\.sender|block\.timestamp|tx\.origin|block\.blockhash|block\.coinbase|block\.difficulty|block\.gaslimit|block\.number|block\.blockhash|block\.coinbase|tx\.gasprice")]
                                    <!--Using selfdestruct and it's alias suicide:-->
                                    or functionCall/functionName//identifier[matches(text()[1], "^selfdestruct$|^suicide$")]
                                    <!--Sending Ether via calls:-->
                                    or functionCall/functionName//identifier[matches(text()[1], "^send$|^transfer$")]
                                    <!--Using low-level calls:-->
                                    or functionCall/functionName//identifier[matches(text()[1], "^call$|^delegatecall$|^callcode$")]
                                    <!--Using inline assembly that contains certain opcodes:-->
                                    or inlineAssemblyStatement
                                ]
                        ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_SHOULD_NOT_BE_VIEW</RuleId>
        <Patterns>
            <Pattern patternId="189abf">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <!--Writing to state variables - лучше сделать через флаги-->
                <!--Emitting events - лучше сделать через флаги-->
                <!--Creating other contracts - лучше сделать через флаги-->
                <!--Calling any function not marked view or pure:- лучше сделать через флаги-->
                <XPath>
                    //functionDefinition
                        [
                            stateMutability/viewType
                            and block/descendant-or-self::*
                                [   <!--Using selfdestruct and it's alias suicide:-->
                                    functionCall/functionName//identifier[matches(text()[1], "^selfdestruct$|^suicide$")]
                                    <!--Sending Ether via calls:-->
                                    or functionCall/functionName//identifier[matches(text()[1], "^send$|^transfer$")]
                                    <!--Using low-level calls:-->
                                    or functionCall/functionName//identifier[matches(text()[1], "^call$|^delegatecall$|^callcode$")]
                                    <!--Using inline assembly that contains certain opcodes:-->
                                    or inlineAssemblyStatement
                                ]
                        ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_SHOULD_RETURN_STRUCT</RuleId>
        <Patterns>
            <!-- Looks for internal and private functions with more than 3 input parameters (Solidity version prior to 0.5.0). -->
            <!-- Фиксируются internal или private функции, у которых больше 3 выходных параметров (pragma < 0.5.0). -->
            <Pattern patternId="7d54ca">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    /sourceUnit
                        [
                            not(pragmaDirective//versionLiteral
                                [matches(text()[1], "^0\.\s*[5-9]\s*\.|^0\.\s*[0-9]{2,}\s*\.|^[1-9]")])
                            and not(pragmaDirective/pragmaExperimental//stringLiteral
                                [text()[1] = "ABIEncoderV2"])
                        ]
                        //functionDefinition[visibleType[matches(text()[1], "internal|private")]]
                        /returnsParameters/parameterList[count(parameter) > 3]
                </XPath>
            </Pattern>
            <!-- Looks for functions with more than 3 output parameters (only in files with Solidity version 0.5.0 and newer or pragma experimental). -->
            <!-- Фиксируются функции, у которых больше 3 выходных параметров (pragma >= 0.5.0 или pragma experimental). -->
            <Pattern patternId="83hf3l">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    /sourceUnit
                        [
                            pragmaDirective//versionLiteral
                                [matches(text()[1], "^0\.\s*[5-9]\s*\.|^0\.\s*[0-9]{2,}\s*\.|^[1-9]")]
                            or pragmaDirective/pragmaExperimental//stringLiteral
                                [text()[1] = "ABIEncoderV2"]
                        ]
                        //functionDefinition/returnsParameters/parameterList[count(parameter) > 3]
                </XPath>
            </Pattern>
            <!-- Looks for function calls with multiple assignment. -->
            <!-- Фиксируются вызовы функций с множественным присваиванием. -->
            <Pattern patternId="e5gh7l">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //expression[text()[1] = "="]
                        [expression[1]/tupleExpression[count(expression) > 3]]
                        [expression[2]/functionCall]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_TRANSFER_IN_LOOP</RuleId>
        <Patterns>
            <!-- Looks for cycles with <addr>.transfer() inside. -->
            <!-- Фиксирует циклы с .transfer() эфиров внутри. -->
            <Pattern patternId="8jdj43">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //statement
                        [forStatement or whileStatement or doWhileStatement]
                        [descendant::functionCall
                            [functionName/identifier[text()[1] = "transfer"]]
                            [callArguments/tupleExpression[count(expression) = 1]]
                        ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_TX_ORIGIN</RuleId>
        <Patterns>
            <!-- Looks for tx.origin occurrence. -->
            <!-- Фиксируется вхождение tx.origin. -->
            <Pattern patternId="12e802">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //environmentalVariable
                        [matches(text()[1], "^tx\.origin$")]
                        /parent::*
                            [parent::*
                                [not(comparison
                                    and expression/environmentalVariable[matches(text()[1], "^msg\.sender$")])
                                ]
                            ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_UINT_CANT_BE_NEGATIVE</RuleId>
        <Patterns>
            <!-- Looks for construction: "for (...; i >= 0; ...) { ... }", "while(i >= 0) {}", "do {} while(i >= 0)", where variable i is of type uint*. -->
            <!-- Фиксирует конструкции: "for (...; i >= 0; ...) { ... }", "while(i >= 0) {}", "do {} while(i >= 0)", где переменная i типа uint*. -->
            <Pattern patternId="11ca45b">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>3</Severity>
                <XPath>
                    //(forStatement | whileStatement | doWhileStatement)
                        /condition/expression
                            [text()[1] = ">="]
                            [expression[2]/primaryExpression//decimalNumber[text()[1] = "0"]]
                            [expression[1]/primaryExpression/identifier
                                [text()[1]
                                    = ancestor::functionDefinition//variableDeclaration
                                        [typeName/elementaryTypeName[matches(text()[1], "uint")]]
                                        /identifier/text()[1]
                                ]
                            ]
                </XPath>
            </Pattern>
            <!-- Looks for construction: "...>=0" for uint variables and structure's members of uint type-->
            <!-- Фиксирует конструкцию: "...>=0" для переменных типа uint и полей структур типа uint. -->
            <Pattern patternId="d48ac4">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //expression
                        [text()[1] = ">="]
                        [expression[2]/primaryExpression//decimalNumber[text()[1] = "0"]]
                        [expression[1]/(primaryExpression/identifier | identifier)
                            [
                                text()[1]
                                    = ancestor::functionDefinition//variableDeclaration
                                        [typeName/elementaryTypeName[matches(text()[1], "uint")]]
                                        /identifier/text()[1]
                                or text()[1]
                                    = ancestor::contractDefinition//(structDefinition/variableDeclaration | stateVariableDeclaration)
                                        [typeName/elementaryTypeName[matches(text()[1], "uint")]]
                                        /identifier/text()[1]
                            ]
                        ]
                </XPath>
            </Pattern>
            <!-- Looks for construction: "...>=0" only for mappings of type: (...=>uint). -->
            <!-- Фиксирует конструкцию: "...>=0" только для мапингов вида (...>=uint). -->
            <Pattern patternId="733fdd">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //expression
                        [text()[1]=">="]
                        [expression[2]//decimalNumber[text()[1] = "0"]]
                        [expression[1]/expression[1]//identifier
                            [text()[1]
                                = ancestor::contractDefinition//stateVariableDeclaration
                                    [typeName/mappingSt/typeName[2]/elementaryTypeName[matches(text()[1],"uint")]]
                                    /identifier/text()[1]
                            ]
                        ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_UNCHECKED_CALL</RuleId>
        <Patterns>
            <!-- Looks for cases, when function calls delegatecall, send, callcode, call do not have ancestors: if, require, assert, return and function call is not a part of variable declaration. -->
            <!-- Фиксируется случаи, когда вызовы функций  call, delegatecall, send, callcode не имеют предков по дереву: if, require, assert, return, вызов функции, не входит в определение переменной. -->
            <Pattern patternId="f39eed">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>3</Severity>
                <XPath>
                    //functionCall
                        [
                            functionName//identifier
                                [matches(text()[1], "^call$|^delegatecall$|^send$|^callcode$")]
                            and not(ancestor::ifStatement)
                            and not(ancestor::returnStatement)
                            and not(ancestor::functionCall)
                            and not(ancestor::variableDeclarationStatement)
                            and not(ancestor::expression and ancestor::expression[text()[1] = "=" or lvalueOperator])
                        ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_UNUSED_FUNCTION_SHOULD_BE_EXTERNAL</RuleId>
        <Patterns>
            <!-- Looks for functions with public visibility, which are not used in contract. -->
            <!-- Фиксирует public функции, неиспользуемые в контракте. -->
            <Pattern patternId="73ufc1">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //(contractDefinition | libraryDefinition)//functionDefinition
                        <!-- Looks for public visibility -->
                        [visibleType[text()[1] = "public"]]
                        <!-- check that there are no function calls in contract -->
                        [identifier
                            [not(text()[1]
                                = ancestor::sourceUnit//functionCall/functionName/identifier/text()[1])
                            ]
                        ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_UPGRADE_TO_050</RuleId>
        <Patterns>
            <!-- Looks for .call() with zero or two and more arguments. -->
            <!-- Ищет .call() с !=1 аргументом. -->
            <Pattern patternId="83k1no">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //functionCall
                        [functionName/identifier[text()[1] = "call"]]
                        [callArguments/tupleExpression[count(expression) != 1]]
                </XPath>
            </Pattern>
            <!-- Looks for "keccak256(...)" with more than one argument. -->
            <!-- Ищет keccak256(a, b, c) с более чем одним аргументом. -->
            <Pattern patternId="901eae">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //functionCall
                        [functionName/identifier[text()[1] = "keccak256"]]
                        [callArguments/tupleExpression[count(expression) > 1]]
                </XPath>
            </Pattern>
            <!-- Looks for fallback function with not external visibility. -->
            <!-- Ищет fallback функции, у которых видимость не external. -->
            <Pattern patternId="91h3sa">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //functionFallBackDefinition/visibleType[text()[1] != "external"]
                </XPath>
            </Pattern>
            <!-- Looks for arrays and structures without storage declaration (storage, memory) for parameters of not external function. -->
            <!-- Ищет массивы и структуры без явного определения места хранения (storage, memory) в параметрах не external функций. -->
            <Pattern patternId="341gim">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //functionDefinition
                        [not(visibleType) or visibleType[text()[1] != "external"]]
                        //parameter
                            [
                                typeName[text()[1] = "[]"]
                                or typeName/elementaryTypeName
                                    [text()[1] = "bytes" or text()[1] = "string"]
                                or typeName//identifier
                                    [text()[1]
                                        = ancestor::contractDefinition//structDefinition/identifier/text()[1]
                                    ]
                            ]
                            [not(storageLocation)]
                </XPath>
            </Pattern>
            <!-- Looks for arrays and structures without storage declaration (storage, memory) for local variables. -->
            <!-- Ищет массивы и структуры без явного определения места хранения (storage, memory) в локальных переменных функций. -->
            <Pattern patternId="441gim">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //functionDefinition
                        //variableDeclaration
                            [
                                typeName[text()[1] = "[]"]
                                or typeName/elementaryTypeName
                                    [text()[1] = "bytes" or text()[1] = "string"]
                                or typeName//identifier
                                    [text()[1]
                                        = ancestor::contractDefinition//structDefinition/identifier/text()[1]
                                    ]
                            ]
                            [not(storageLocation)]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_USING_INLINE_ASSEMBLY</RuleId>
        <Patterns>
            <!-- Looks for assembly usage, except for construction: assembly { ... := extcodesize(...) }. -->
            <!-- Фиксирует конструкцию: "assembly", кроме конструкции: assembly { ... := extcodesize(...) }. -->
            <Pattern patternId="109cd5">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //statement/inlineAssemblyStatement/inlineAssemblyBlock
                        [not(assemblyItem/assemblyAssignment
                            [assemblyExpression/assemblyCall/identifier
                                [matches(text()[1], "^extcodesize$")]
                            ])
                        ]
                        /ancestor::inlineAssemblyStatement
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_VAR</RuleId>
        <Patterns>
            <!-- Looks for variable declaration as "var ... = <number>". -->
            <!-- Фиксируется случаи определения переменных, как var ...= число. -->
            <Pattern patternId="d28aa7">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //varDeclaration
                        [expression//primaryExpression/numberLiteral/decimalNumber]
                </XPath>
            </Pattern>
            <!-- Looks for variable declaration using "var". -->
            <!-- Фиксируется случаи определения переменных, как var имя переменной. -->
            <Pattern patternId="f77619">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //varDeclaration[expression/primaryExpression/identifier]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_VAR_IN_LOOP_FOR</RuleId>
        <Patterns>
            <!-- Looks for construction: "for (var ...; ... <number bigger than 255>; ... ++)". -->
            <!-- Фиксирует конструкцию: "for (var ...; ... число более 255; ... ++)". -->
            <Pattern patternId="f176ab">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //forStatement
                        [expression[1]/varDeclaration]
                        [condition/expression/expression/primaryExpression
                            [numberLiteral/decimalNumber
                                [matches(text()[1], "^[0-9]+$")]
                                &gt; 255
                            ]
                        ]
                        [expression[2]/twoPlusMinusOperator/incrementOperator]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_VISIBILITY</RuleId>
        <Patterns>
            <!-- Looks for non-external funstions in an interface. -->
            <!-- Фиксирует ситуацию, когда в интерфейсе для функции или fallback функции видимость не external. -->
            <Pattern patternId="23rt6g">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //interfaceDefinition/contractPartDefinition
                        /(functionDefinition | functionFallBackDefinition)
                        /visibleType[not(matches(text()[1], "^external$"))]
                </XPath>
            </Pattern>
            <!-- Looks for fallback function without explicit visibility declaration. -->
            <!-- Фиксирует ситуацию, когда для функции или fallback функции не определена видимость. -->
            <Pattern patternId="910067">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //(functionDefinition | functionFallBackDefinition)[not(visibleType)]
                </XPath>
            </Pattern>
            <!-- Looks for fallback function that is neither external nor public. -->
            <!-- Фиксирует ситуацию, когда в контракте для fallback функции видимость не external или public. -->
            <Pattern patternId="d67c21">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //contractDefinition/contractPartDefinition/functionFallBackDefinition/visibleType
                        [not(matches(text()[1], "^external$|^public$"))]
                </XPath>
            </Pattern>
            <!-- Looks for state variables without explicit visibility declaration. -->
            <!-- Фиксирует ситуацию, когда для переменной состояния не определена видимость. -->
            <Pattern patternId="b51ce0">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //stateVariableDeclaration[not(visibleType)]
                </XPath>
            </Pattern>
            <!-- Looks for constructor with external or private visibility. -->
            <!-- Фиксирует ситуацию, когда у конструктора видимость external или private. -->
            <Pattern patternId="321aca">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //functionDefinition
                        [text()[1] = "constructor"]
                        [visibleType[matches(text()[1], "^external$|^private$")]]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_WRONG_SIGNATURE</RuleId>
        <Patterns>
            <!-- Looks for "bytes4(keccak256(<signature>))" and "bytes4(sha3(<signature>))" with uint or int in <signature>. -->
            <!-- Фиксирует конструкции в которых используется bytes4(keccak256(signature)) bytes4(sha3(signature)), где в signature есть uint, int. -->
            <Pattern patternId="ui25n6">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //functionCall
                        [callArguments//primaryExpression
                            [
                                contains(stringLiteral, "uint,")
                                or contains(stringLiteral, "int,")
                                or contains(stringLiteral, "uint)")
                                or contains(stringLiteral, "int)")
                                or contains(stringLiteral, "uint[")
                                or contains(stringLiteral, "int[")
                            ]
                        ]
                        [callArguments/tupleExpression/expression[1]
                            [typeConversion[typeName/elementaryTypeName[text()[1] = "bytes4"]]]
                            [//functionCall/functionName/identifier[matches(text()[1], "^sha3$|^keccak256$")]]
                        ]

                </XPath>
            </Pattern>
            <Pattern patternId="rec155">
            <!-- Looks for "abi.encodeWithSignature(<signature>)" with uint or int in <signature>. -->
            <!-- Фиксирует конструкции в которых используется "abi.encodeWithSignature(<signature>)", где в signature есть uint, int. -->
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //functionCall/callArguments
                        [tupleExpression/expression
                            [expression/primaryExpression/identifier[text()[1] = "abi"]]
                            [functionCall/functionName/identifier[text()[1] = "encodeWithSignature"]]
                            [
                                functionCall//primaryExpression
                                    [
                                        contains(stringLiteral, "uint)")
                                        or contains(stringLiteral, "int)")
                                        or contains(stringLiteral, "uint,")
                                        or contains(stringLiteral, "int,")
                                        or contains(stringLiteral, "uint[")
                                        or contains(stringLiteral, "int[")
                                    ]
                            ]
                        ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
</Rules>
